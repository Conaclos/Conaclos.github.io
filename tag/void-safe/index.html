<!DOCTYPE html><html lang="en-US"><head>
<base href="http://victorien.elvinger.fr" />
<link rel="stylesheet" type="text/css" href="http://victorien.elvinger.fr/wp-content/cache/minify/000000/M9DPzU_XLy6pzEnVMQCzgVg3NzEzDwA.css" media="all" /><meta charset="UTF-8" /><meta name="viewport" content="width=device-width" /><title>void-safe &#8211; Another Horizon</title> <!--[if lt IE 9]><script src="http://victorien.elvinger.fr/wp-content/themes/mog/js/html5.js" type="text/javascript"></script><![endif]--><script type="text/javascript">/*<![CDATA[*/window._wpemojiSettings={"baseUrl":"http:\/\/s.w.org\/images\/core\/emoji\/72x72\/","ext":".png","source":{"concatemoji":"http:\/\/victorien.elvinger.fr\/wp-includes\/js\/wp-emoji-release.min.js?ver=4.2.2"}};!function(a,b,c){function d(a){var c=b.createElement("canvas"),d=c.getContext&&c.getContext("2d");return d&&d.fillText?(d.textBaseline="top",d.font="600 32px Arial","flag"===a?(d.fillText(String.fromCharCode(55356,56812,55356,56807),0,0),c.toDataURL().length>3e3):(d.fillText(String.fromCharCode(55357,56835),0,0),0!==d.getImageData(16,16,1,1).data[0])):!1}function e(a){var c=b.createElement("script");c.src=a,c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var f,g;c.supports={simple:d("simple"),flag:d("flag")},c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.simple&&c.supports.flag||(g=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",g,!1),a.addEventListener("load",g,!1)):(a.attachEvent("onload",g),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),f=c.source||{},f.concatemoji?e(f.concatemoji):f.wpemoji&&f.twemoji&&(e(f.twemoji),e(f.wpemoji)))}(window,document,window._wpemojiSettings);/*]]>*/</script><style type="text/css">img.wp-smiley,img.emoji{display:inline !important;border:none !important;box-shadow:none !important;height:1em !important;width:1em !important;margin:0 .07em !important;vertical-align:-0.1em !important;background:none !important;padding:0 !important}</style><link rel='stylesheet' id='opensans-css'  href='http://fonts.googleapis.com/css?family=Open+Sans&#038;ver=4.2.2' type='text/css' media='all' /><link rel='stylesheet' id='josefinslab-css'  href='http://fonts.googleapis.com/css?family=Josefin+Slab%3A600&#038;ver=4.2.2' type='text/css' media='all' /><script type="text/javascript" src="http://victorien.elvinger.fr/wp-content/cache/minify/000000/M9bPKixNLarUMYYydHMz04sSS1L1cjPzAA.js"></script><meta name="keywords" content="attaché, attached, detachable, Eiffel, inference, patron, type, void-safe" /><script type="text/javascript">/*<![CDATA[*/(function(a,e){function f(){var d=0;if(e.body&&e.body.offsetWidth){d=e.body.offsetHeight}if(e.compatMode=="CSS1Compat"&&e.documentElement&&e.documentElement.offsetWidth){d=e.documentElement.offsetHeight}if(a.innerWidth&&a.innerHeight){d=a.innerHeight}return d}function b(g){var d=ot=0;if(g.offsetParent){do{d+=g.offsetLeft;ot+=g.offsetTop}while(g=g.offsetParent)}return{left:d,top:ot}}function c(){var l=e.querySelectorAll("[data-lazy-original]");var j=a.pageYOffset||e.documentElement.scrollTop||e.body.scrollTop;var d=f();for(var k=0;k<l.length;k++){var h=l[k];var g=b(h).top;if(g<(d+j)){h.src=h.getAttribute("data-lazy-original");h.removeAttribute("data-lazy-original")}}}if(a.addEventListener){a.addEventListener("DOMContentLoaded",c,false);a.addEventListener("scroll",c,false)}else{a.attachEvent("onload",c);a.attachEvent("onscroll",c)}})(window,document);/*]]>*/</script></head><body class="archive tag tag-void-safe tag-42"><div id="page" class="hfeed site"> <header id="masthead" class="site-header" role="banner"> <hgroup><h1 class="site-title"> <a href="http://victorien.elvinger.fr/" title="Another Horizon" rel="home"><div class="header-title">Another Horizon</div> </a></h1><h2 class="site-description"></h2> </hgroup><nav role="navigation" class="site-navigation main-navigation"><h1 class="assistive-text">Menu</h1><div class="assistive-text skip-link"><a href="#content" title="Skip to content">Skip to content</a></div><div class="menu"><ul><li class="page_item page-item-7"><a href="http://victorien.elvinger.fr/author/">Author</a></li></ul></div> </nav> </header><div id="main" class="site-main"><section id="primary" class="content-area"><div id="content" class="site-content" role="main"> <header class="page-header"><h1 class="page-title"> Tag Archives: <span>void-safe</span></h1> </header> <article id="post-62" class="post-62 post type-post status-publish format-standard hentry category-any category-eiffel-language tag-attache tag-attached tag-detachable tag-eiffel tag-inference tag-patron tag-type tag-void-safe"> <header class="entry-header"><h1 class="entry-title"><a href="http://victorien.elvinger.fr/proposition-inference-de-type-en-eiffel/" title="Permalink to Inférence de type en Eiffel" rel="bookmark">Inférence de type en Eiffel</a></h1><div class="entry-meta"> <a href="http://victorien.elvinger.fr/proposition-inference-de-type-en-eiffel/" title="20:42" rel="bookmark"><time class="entry-date" datetime="2013-04-08T20:42:24+00:00">April 8, 2013</time></a><span class="byline"> by <span class="author vcard"><a class="url fn n" href="http://victorien.elvinger.fr/author/conaclos/" title="View all posts by Victorien ELVINGER" rel="author">Victorien ELVINGER</a></span></span></div> </header><div class="entry-content"><p>L’inférence de type est un mécanisme permettant au compilateur de déduire automatiquement le type d’une cible en se basant sur le type de la source.<br /> L’utilisateur n’a alors plus besoin de déclarer ses variables et donc de se soucier du nom du type qui rentre en jeu. Le programme obtenu est plus générique, plus à même aux changements. En effet si le type de la source change, le type de la cible est automatiquement modifié.<br /> L’inférence de type apporte une plus grande souplesse au typage statique.</p><h2>Typage statique</h2><p>Exceptés deux cas (nous en verrons un par la suite), une variable ou un attribut en Eiffel doit toujours être déclaré.<br /> Ci-dessous est définie une classe <span translate="no">LINE</span> avec une procédure de création (constructeur) <span translate="no">from_complexs</span> et deux attributs <var translate="no">first</var> et <var translate="no">second</var> de type <span translate="no">POINT</span>.<br /> La procédure de création prend deux paramètres de type <span translate="no">COMPLEX</span> et crée les deux attributs.</p><pre><code class="eiffel-language" translate="no">
class
	LINE

create
	from_complexs

feature -- Initialization

	from_complexs (a, b: COMPLEX)
		do
			create first.from_complex (a)
			create second.from_complex (b)
		end

feature -- Access
	
	origin: POINT
		once
			create Result
		end

	first, second: POINT

end
</code></pre><h2>Typage ancré</h2><p>Le typage ancré a été introduit dans Eiffel pour apporter une plus grande <a href="qualities-of-a-system/#quality.flexibility">flexibilité</a> au typage statique et pour permettre la covariance dont nous ne parlerons pas dans cet article.<br /> Il permet de spécifier que le type d’une cible est identique au type d’une source.</p><pre><code class="eiffel-language" translate="no">
origin: POINT
	once
		create Result
	end

first, second: like origin
</code></pre><p>Les attributs <var translate="no">first</var> et <var translate="no">second</var> sont du même type que la fonction (à exécution unique) <var translate="no">origin</var>.</p><p>Le typage ancré permet d’écrire un programme plus générique et évolutif. Cependant, la déclaration des variables est toujours nécessaire.</p><h2 translate="no">Eiffel void safe</h2><p>Nous souhaiterions donner à l’utilisateur la possibilité de spécifier un paramètre comme vide (nul).<br /> Une variable, ou un attribut pouvant être affecté de la valeur vide doit être déclaré comme « <span translate="no" class="eiffel-language">detachable</span> ».<br /> La variable étant potentiellement vide, il est nécessaire de faire un test d’attachement avant de lui appliquer des opérations.</p><pre><code class="eiffel-language" translate="no">
from_complexs (a: COMPLEX; b: detachable COMPLEX)
	do
		create first.from_complex (a)
		if b /= Void then
		      create second.from_complex (b)
		else
		      create second.from_complex (origin)
		end
	end
</code></pre><p><code class="eiffel-language" translate="no">b /= Void</code> peut être remplacé par <code class="eiffel-language" translate="no">attached b</code>.<br /> <var translate="no">b</var> est en lecture seule à l&#8217;intérieur de la condition.</p><p>En revanche aucune opération n’est applicable sur un attribut détachable, car sa valeur peut être modifiée lors de l’appel d’autres procédures. Il est donc nécessaire d’avoir un mécanisme qui fasse à la fois un test d’attachement et une affectation à une variable locale. Le patron d’attachement est ce mécanisme. Il peut bien entendu être utilisé avec des variables locales comme illustrées ci-dessous.</p><pre><code class="eiffel-language" translate="no">
from_complexs (a: COMPLEX; b: detachable COMPLEX)
	do
		create first.from_complex (a)
		if attached b as c then
		      create second.from_complex (c)
		else
		      create second.from_complex (origin)
		end
	end
</code></pre><p>Si <var>b</var> est attaché à un objet alors il est affecté à la variable locale <var>c</var>. La variable nouvellement créée est en lecture seule comme le sont les paramètres formels ou les constantes.<br /> Le mécanisme introduit par la même occasion une inférence de type.</p><h2>Proposition d’une inférence de type</h2><p>Une première approche pourrait être de déduire le type d’une variable lors de sa première affectation.</p><pre><code class="eiffel-language" translate="no">
new_target := source
</code></pre><p>Mais cette approche à plusieurs inconvénients :<br /> — Le compilateur ne peut pas détecter les erreurs de frappes. C’est une erreur récurrente et qui n’est pas si facile à identifier sans le compilateur.</p><pre><code class="eiffel-language" translate="no">
new_target := source
mew_target := source2
</code></pre><p>— Nous pouvons par erreur utiliser le nom d’un attribut de notre classe. Le compilateur n’a aucun moyen d’identifier cette erreur.<br /> — La sémantique d’une affectation devient plus complexe. En effet, elle peut conduire à la création d’une nouvelle variable.</p><p>Nous avons besoin d’un mécanisme distinct d’une affectation qui provoque la création d’une nouvelle variable.</p><p>En faisant une petite recherche sur les moteurs de recherche, on peut trouver une proposition qui va dans ce sens.</p><pre><code translate="no">
new_target ::= source
</code></pre><p>Cependant la syntaxe utilisée est nouvelle et se démarque peu d’une affectation.</p><p>En nous inspirant du patron d’attachement, nous pouvons créer un mécanisme simple.</p><pre><code class="eiffel-language" translate="no">
source as new_target
</code></pre><p>Quel est le type de la cible ?<br /> La cible est du type de la source. Lorsque la source est détachable, le mécanisme a peu d’intérêt. Dans ce cas, il est préférable d’utiliser le patron d’attachement. Nous pouvons donc réserver ce mécanisme aux sources de type attaché.</p><p>La variable nouvellement créée doit-elle être en lecture seule ?<br /> Le mot clé « <span class="eiffel-language" translate="no">as</span> » suggère une liaison plus forte entre la cible et la source qu’avec une affectation.<br /> Les variables en lecture seule garantissent l’accès à un même objet tout au long de la routine, évitant ainsi une erreur d’interprétation.<br /> Je pense qu’il est donc judicieux d’avoir la variable nouvellement créée en lecture seule.</p><p>Ce choix peut toujours être révisé dans une version ultérieure. En effet, l’introduction de la mutabilité d’une variable inférée sera rétrocompatible, l’inverse ne l’est pas.<br /> Ce choix est également motivé par la volonté d’avoir un maximum de similitudes sémantiques avec le patron d’attachement.</p><pre><code class="eiffel-language" translate="no">
if attached (source as new_target) then
	new_target.do_something -- compilation error
end
</code></pre><p>la compatibilité est atteinte en considérant que <code class="eiffel-language" translate="no">source as new_target</code> est une expression qui donne comme résultat la variable nouvellement créée.<br /> Nous pouvons remarquer un changement sémantique qui n’a aucune conséquence effective. En effet lorsque la source est détachable, le type de la cible n’est plus attaché, mais détachable.</p><p>Cependant, la distinction nette entre expression et déclaration en Eiffel pousse à garder une séparation entre le mécanisme proposé ici et le patron d’attachement.</p><p>Résumons :<br /> 1. Le type de la source doit être attaché.<br /> 2. Le nom de la cible ne doit pas identifier une autre variable.<br /> 3. Le type de la cible est identique à celui de la source.<br /> 4. La cible est en lecture seule.<br /> 5. Le mécanisme provoque la création d’une nouvelle variable et son initialisation.<br /> 6. Le mécanisme n’est pas une expression, mais une déclaration.</p></div> <footer class="entry-meta"> <span class="sep"> | </span> <span class="tags-links"> Tagged <a href="http://victorien.elvinger.fr/tag/attache/" rel="tag">attaché</a>, <a href="http://victorien.elvinger.fr/tag/attached/" rel="tag">attached</a>, <a href="http://victorien.elvinger.fr/tag/detachable/" rel="tag">detachable</a>, <a href="http://victorien.elvinger.fr/tag/eiffel/" rel="tag">Eiffel</a>, <a href="http://victorien.elvinger.fr/tag/inference/" rel="tag">inference</a>, <a href="http://victorien.elvinger.fr/tag/patron/" rel="tag">patron</a>, <a href="http://victorien.elvinger.fr/tag/type/" rel="tag">type</a>, <a href="http://victorien.elvinger.fr/tag/void-safe/" rel="tag">void-safe</a> </span> <span class="sep"> | </span> <span class="comments-link"><a href="http://victorien.elvinger.fr/proposition-inference-de-type-en-eiffel/#respond"><span class="dsq-postid" data-dsqidentifier="62 http://victorien.elvinger.fr/?p=62">Leave a comment</span></a></span> </footer> </article></div> </section><div id="secondary" class="widget-area" role="complementary"> <aside id="categories-2" class="widget widget_categories"><h1 class="widget-title">Categories</h1><ul><li class="cat-item cat-item-1"><a href="http://victorien.elvinger.fr/category/any/" title="Any items">Any</a></li><li class="cat-item cat-item-38"><a href="http://victorien.elvinger.fr/category/eiffel-language/" >Eiffel language</a></li><li class="cat-item cat-item-37"><a href="http://victorien.elvinger.fr/category/technology/" >Technology</a></li></ul> </aside></div></div><footer id="colophon" class="site-footer" role="contentinfo"><div class="site-info"> <a href="http://wordpress.org/" title="A Semantic Personal Publishing Platform" rel="generator">running on WordPress</a> <span class="sep"> | </span> Theme: Mog by <a href="http://hndr.me/" rel="designer">hndr</a>.</div> </footer></div><script type="text/javascript">/*<![CDATA[*/var disqus_shortname='anotherhorizon';(function(){var nodes=document.getElementsByTagName('span');for(var i=0,url;i<nodes.length;i++){if(nodes[i].className.indexOf('dsq-postid')!=-1){nodes[i].parentNode.setAttribute('data-disqus-identifier',nodes[i].getAttribute('data-dsqidentifier'));url=nodes[i].parentNode.href.split('#',1);if(url.length==1){url=url[0];}
else{url=url[1];}
nodes[i].parentNode.href=url+'#disqus_thread';}}
var s=document.createElement('script');s.async=true;s.type='text/javascript';s.src='//'+disqus_shortname+'.disqus.com/count.js';(document.getElementsByTagName('HEAD')[0]||document.getElementsByTagName('BODY')[0]).appendChild(s);}());/*]]>*/</script><script type="text/javascript" src="http://victorien.elvinger.fr/wp-content/cache/minify/000000/M9DPzU_XzyrWL85NzMnRzU3NKwUA.js"></script></body></html>